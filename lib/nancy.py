"""
Reformats and parses output generated by nancy, a Golang dependency auditor.
"""

import re


def convert_to_json(i_file):
    """
    Opens a file containing nancy output (which is basically prettified stdout unfortunately) and maps it to a JSON object which could then be parsed. 
    We could do the reporter issue logic in this method as well but for future-proofing we'll seperate the reporting and marshalling logic.

    After parsing, the returned object will have the format:

    [
        {
            "dependency": "foobar",
            "version": "0.0.0",
            "vulnerability_amount": 0,
            "vulnerabilities": [
                {
                    "description": "loren ipsum",
                    "id": "00000000-0000-0000-0000-000000000000",
                    "url": "https://ossindex.sonatype.org/vuln/00000000-0000-0000-0000-000000000000" 
                },
                ...
            ]
        },
        ...
    ]
    """

    nancy_json_object = []

    # This regular expression matches each dependency we're dealing with.
    issue_expression = r"\[[0-9]+\/.+?(?=\[[0-9]|Audited)"
    ie_compiled = re.compile(issue_expression, re.MULTILINE|re.DOTALL)

    # Read the file as a single object and run the above regex through it.
    i_file_string_object = i_file.read()
    for dependency_match in ie_compiled.finditer(i_file_string_object):

        # print()

        # For each dependency match (w/o unnecessary whitespace)
        dependency = dependency_match.group(0).strip()

        # Get the first line - it's the title, which contains the dependency name and amount of vulns we have to deal with.
        title_line = dependency.split("\n")[0]

        # Remove any instances of whitespace blobs from the string. We essentially want single spaces any time there needs to be one.
        title_line = " ".join(title_line.split())

        # Look for issues with vulnerabilities and print the
        # amount to stdout

        if "affecting installed version" in title_line:

            # Get the dependency name and version
            dependency_match = title_line.split(" ")[1]
            # Remove the "pkg" string from the dependency path
            dependency_match = dependency_match.split(":")[1]
            dependency_name = dependency_match.split("@")[0]
            dependency_version = dependency_match.split("@")[1]

            # Create a JSON object for this dependency
            dependency_json_object = {
                "dependency": dependency_name,
                "version": dependency_version,
                "vulnerability_amount": 0,
                "vulnerabilities": []
            }

            # Split the line based off its whitespaces, then get and set the reported vulnerability amount
            vuln_amount = title_line.split(" ")[3]
            dependency_json_object["vulnerability_amount"] = vuln_amount

            # Output to stdout the amount of vulnerabilities associated. Not really needed, but hey.
            va_stdout_string = "- " + vuln_amount
            if int(vuln_amount) > 1:
                va_stdout_string += " vulnerabilities affect "
            else:
                va_stdout_string += " vulnerability affects "
            va_stdout_string += "version " + dependency_version + " of " + dependency_name + "!"
            print(va_stdout_string)

            vulnerability_expression = r"(?P<issue_format>CVE-[0-9]+-[0-9]+|CWE-[0-9]+).+?\n(?P<description>.+?)ID: (?P<id>[a-z0-9-]+)?.+?Details: (?P<detail_url>.+?vuln\/[a-z0-9-]+)"
            ve_compiled = re.compile(vulnerability_expression, re.MULTILINE|re.DOTALL)

            for vulnerability in ve_compiled.finditer(dependency):

                # Get the first portion of the line (CVE-XXXX-XXXX or CWE-XX) and use it as the mini-title of the specific vuln we're dealing with
                issue_format = vulnerability.group("issue_format")

                vulnerability_description = "(" + issue_format + ") " + vulnerability.group("description").rstrip()

                # Create the vulnerability dictionary
                vulnerability_json_object = {
                    "description": vulnerability_description
                }

                # Provide an OSS Index link to further information
                vuln_url = vulnerability.group("detail_url")
                vulnerability_json_object["url"] = vuln_url

                # Get just the UUID from the URL
                vuln_id = vuln_url.split("vuln/")[1]
                vulnerability_json_object["id"] =  vuln_id

                # Add the vulnerability to the dependency object
                dependency_json_object["vulnerabilities"].append(vulnerability_json_object)

            # Add the information on the dependency to the final object!
            nancy_json_object.append(dependency_json_object)
    
    # Now that we have all issues in one list, lets return it.
    return nancy_json_object


def parse(i_file, reporter, outputter):
    json_object = convert_to_json(i_file) 

    if len(json_object) > 0:
        issue_type = "dependencies"
        tool_name = "nancy"
        description = ""

        for dependency in json_object:

            # The dependency field is actually the location of the dependency with the name of the dep itself.
            dependency_source = dependency["dependency"]
            location = dependency_source

            # For now, we'll just populate the title of the issue with only the dep name to save space
            dependency_name = dependency_source.split('/')[-1]
            dependency_version = dependency["version"]

            # Set the title of the issue
            title = "Use of vulnerable Go dependency - " + dependency_name + "@" + dependency_version
            # print(title)

            description = "Version " + dependency_version + " of " + dependency_name + ", a Go dependency pulled by the scanned project, was found to be vulnerable to security issues. Such vulnerabilities have been listed below.\n\n"

            for vulnerability in dependency["vulnerabilities"]:
                description += vulnerability["description"] + "\nFurther information can be found at " + vulnerability["url"] + "\n\n"

            recommendation = "Update " + dependency_name + " to the latest stable version to ensure the project makes use of the latest security patches and fixes that the new version comes with.\n\nIf it is not possible to update the dependency, then consider the risk exposed to the business and project.\nAlso, as a last case consider identifying and using alernative dependencies that provide similar functionality albeit without the original vulnerability."

            reporter.add(
                issue_type,
                tool_name,
                title,
                description,
                location,
                recommendation
            )

    outputter.add("- [✓] Done!")
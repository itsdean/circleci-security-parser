# circleci-security-parser
Python project that absorbs tool output generated by https://github.com/itsdean/circleci-security and coalesces them into one singular csv containing all security issues.

# Table of Contents
  * [Input Files](#input-files)
  * [Output](#output)
  * [Fail Thresholds](#fail-thresholds)
  * [Allowlisting issues](#allowlisting-issues)
  * [Uploading to an S3 bucket](#uploading-to-an-s3-bucket)
 
# Input Files
The parser currently supports the following security tool output:
  * [insider-cli](https://github.com/insidersec/insider)
  * [gosec](https://github.com/securego/gosec)
  * [nancy](https://github.com/sonatype-nexus-community/nancy)
  * [gitleaks](https://github.com/zricethezav/gitleaks)
  * [trivy](https://github.com/aquasecurity/trivy)
  * [SHeD](https://github.com/itsdean/shed)
  * Snyk

The output generated by each tool **must have "results_" followed by the name of the tool** in it's filename. For example, output created by trivy has to be named `results_trivy.json` for the parser to consume it, but it can be called `results_trivy_loren_ipsum.json` and will still be accepted/consumed.

# Output
The parser will output any issues it parses into a single .csv file, allowing for a single file containing all security tool output. Each issue is wrapped/mapped to common headings to aid in further dissemination.


# Configuration
The parser supports the loading of settings from a yaml file to customise the way the parser works.

## .security/parser.yml
By default, the parser looks for the `.security/parser.yml` file in the root of the target input directory.
If it cannot find this file, it will default to its standard configuration (a fail threshold of High severity, no uploading to S3 buckets, and returning non-zero exit codes).

You can provide the location of the yaml file with the `-c` command line argument.

## Fail Thresholds
If the parser identifies an issue with a severity greater than or equal to its "fail threshold", it will return an error code relative to the issues with the greatest risk.

If not explicitly defined in the configuration file, `fail_threshold` is set to `"high"` by default, meaning the parser will return a non-zero exit code if it detects issues with a severity of High or Critical.

The mapping can be found below:

| `fail_threshold` YAML value | Severity | Return Code |
| :-: | :-: | :-: |
| "critical" | Critical |	5 |
| "high" | High |	4 |
| "medium" | Medium |	3 |
| "low" | Low |	2 |
| "informational" | Informational |	1 |
| "off" | N/A (no thresholds at all) | 0 |

The fail threshold can be manually set within the configuration file, as so:
```
fail_threshold: "medium"
```

## Allowlisting issues
Each issue reported by the parser contains its own unique "Issue ID" - a long hash that maps to the issue's description and location.

There may be a lot of false positives that the parser ends up consuming. To reduce the noise, you can provide a list of issue IDs in the configuration file - future runs of the parser against the same input files will not take these issues into account.

To allow specific issues, within the configuration file add the relevant IDs in the following format:
```
allowlist:
  ids:
    - issue_1_hash
    - issue_2_hash
```

It may also be prudent to allow files within certain paths (such as those containing dummy code or test fixtures). To do do, add the relevant paths in the following format:
```
allowlist:
  paths:
    - path1
    - path2
```

## Uploading to an S3 bucket
If you wish to store a history of output (for example if the parsing is executed from within in a CI/CD pipeline) then it is possible to upload to an AWS S3 bucket.

To do so, set the following flag in the configuration file:
```
aws: true
```

The parser will then attempt to authenticate and upload (both the raw tool input and the parsed output) via the following environment variables:
```
PARSER_AWS_BUCKET_NAME # name of the s3 bucket to upload to
PARSER_AWS_AK_ID # AWS access key
PARSER_AWS_SK # AWS secret key
```

## JIRA Integration
If you use JIRA to keep track of security issues/vulnerabilities, the parser can connect to your JIRA board, identify tickets that map to parsed issues and determine (based off their status) if they should continue to be reported or not. An example situation could be that an issue is a false positive, in which case the parser should omit this from the report.

**There are a number of pre-requisites for this integration to work:**

1) Populating the following in the configuration file:
```
jira: true

jira_config:
 project: "the name of your JIRA project/board"
 issue_type: "the issue type your security tickets are raised under"
 
 # you may need to create and populate a customfield for hashes/uids if you do not already
 hash_field: "the customfield used to store the hashes of each parser-reported issue
 
 # ticket statuses used to determine if an issue could be disregarded due to valid reasons (i.e. false positive, duplicate, accepted)
 accepted_statuses:
  - false positive
  - duplicate
```

2) Setting the following environment variables:
```
JIRA_SERVER # the url for your JIRA server
JIRA_USERNAME # the username to authenticate to the JIRA server
JIRA_API_TOKEN # the generated API token used to authenticate to the JIRA server
```



"""
Parses output generated by the Snyk CircleCI Orb.
"""

import json
import re
from bs4 import BeautifulSoup
from markdown import markdown


def get_node_report_upgrades(snyk_json_object, ifile_name, reporter):
    """
    Looks for the upgrade solutions proposed by Snyk so that a single recommendation/list of things to upgrade can be passed to a team. 

    In most cases this is better than assigning n*N issues to a team; just assign the single issue with all the fixes detailed.
    """

    print("- 1 issue generated from common dependency fix steps...")

    issue_type = "dependencies"
    tool_name = "snyk_node"
    title = "Overall Use of Outdated Node Dependencies"
    location = "unknown"

    description = """The project in scope made use of outdated Node dependencies, which were susceptible to known vulnerabilities.\n\nPlease note: each dependency in the \"Location\" column has been individually reported as well for\ntracking purposes - this specific issue has been reported to identify and detail the path of least resistence when updating\ndependencies, to cover/mitigate the most vulnerabilities at the same time.
    """ 

    recommendation = """Upgrade all of the packages mentioned in the \"Location\" column to AT LEAST the version mentioned.\n\nWhere possible, update dependencies to their latest stable versions to make use of all possible\nsecurity patches and updates, but please double-check that updating does not break business-critical features before\ndoing so.
    """

    # Disclose the project name first, then create some space to insert the upgrade paths below.
    location = snyk_json_object["projectName"] + "\n\n"

    upgrade_paths = snyk_json_object["remediation"]["upgrade"]

    for dependency_name, upgrade_details in upgrade_paths.items():

        # The values are in the form package@semver, so lets split via the @ and grab the dependency name.
        dependency_name = dependency_name.split("@")[0]

        # dependency_name actually has the used version attached (rather than the version we should be updating to), so we'll have to jump in its dict value and obtain the version to upgrade to.
        dependency_min_version = upgrade_details["upgradeTo"].split("@")[1]

        # add it to the location column as a dep that should be updated
        location += "> Update " + dependency_name + " to at least version " + dependency_min_version + "\n"

    reporter.add(
        issue_type,
        tool_name,
        title,
        description,
        location,
        recommendation, 
        ifile_name
    )


def parse_node(i_file, reporter):
    """
    Isolates each Snyk finding from the input_file and isolates them into individual dependency issues. Also passes the file over to get_node_report_upgrades as part of the Snyk input file contains the steps to fix multiple dependencies at the same time when updating.

    In the meantime, for tracking reasons we'll report both the grouped and isolated solutions/issues.
    """

    issue_type = "dependencies"
    tool_name = "snyk_node"
    ifile_name = i_file.name

    # setting empty vars in case they aren't populated later down the line
    cve_value = ""
    location = ""

    # Load the file into a blob
    i_file_json_object = json.load(i_file)

    if "error" not in i_file_json_object:

        vulnerabilities = i_file_json_object["vulnerabilities"]
        print("- " + str(len(vulnerabilities)) + " dependencies reported by " + tool_name + "!")

        # The rest of the method will individually report each bad dependency, but for brevity what we would do is report an issue that reports outdated dependencies as a whole along with their upgrade paths. :)
        get_node_report_upgrades(i_file_json_object, ifile_name, reporter)

        for vulnerability in vulnerabilities:
            raw_output = vulnerability
            title = vulnerability["title"]
            severity = vulnerability["severity"]

            # Both the description and recommendation are shoved into the same key by Snyk, so we have to split them.
            # Also, Snyk dumps the output pre-formatted so we've gotta deal with this to get raw sentences we can deal with.
            snyk_description = vulnerability["description"]

            # Get rid of the Markdown and odd escaped characters.
            # BS4 is built for this, so lets not re-invent the wheel again.
            sd_html = markdown(snyk_description)
            sd_text = "".join(BeautifulSoup(sd_html, features="html.parser").findAll(text=True))

            # Get rid of all remaining new lines.
            description = sd_text.replace("\n", " ")

            # We have to remove the "Overview" heading from the description as we're using the "Description" header
            d_delim_start = "Overview "
            description = description[
                len(d_delim_start) :
            ]

            # now we need to return the first two sentences of the description only. split the description into individual sentences using a regex, then join the first two elements.
            description = re.split(r'\. ', description)
            description = ". ".join(description[:2]) + '.'

            r_delim_start = "Remediation\n"
            r_delim_end = "References"
            recommendation = sd_text[
                sd_text.index(r_delim_start) + len(r_delim_start) : sd_text.index(r_delim_end)
            ]
            recommendation = sd_text[sd_text.index("Remediation\n") + len("Remediation\n"):sd_text.index("\nReferences")]

            if "Otherwise, " in recommendation:
                recommendation = recommendation.split("Otherwise, ")[1]

            # Okay, lets find out which exact dependency is vulnerable by merging a specific list together
            location = " > ".join(vulnerability["from"])

            # Set cve_value to be equal to the CVE associated with the issue, but only if there is one.
            if vulnerability["identifiers"]["CVE"]:
                cve_value = vulnerability["identifiers"]["CVE"][0]

            # Create an issue using all of the fields we have populated with values
            reporter.add(
                issue_type,
                tool_name,
                vulnerability["packageName"] + " - " + title,
                description,
                location,
                recommendation,
                ifile_name,
                raw_output = raw_output,
                severity = severity,
                cve_value = cve_value
            )

    else:

        print("[x] The results of this scan apparently failed - please see the following error obained from the output file: \n[x] > " + i_file_json_object["error"])